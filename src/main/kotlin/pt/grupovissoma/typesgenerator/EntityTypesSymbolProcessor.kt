package pt.grupovissoma.typesgenerator

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ksp.*
import jakarta.persistence.Entity
import jakarta.persistence.Id

class EntityTypesSymbolProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
    private val options: Map<String, String>
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbols = resolver.getSymbolsWithAnnotation(Entity::class.qualifiedName!!)
            .filterIsInstance<KSClassDeclaration>()
            .toList()

        if (symbols.isEmpty()) {
            return emptyList()
        }

        val deferredSymbols = mutableListOf<KSAnnotated>()

        symbols.forEach { classDeclaration ->
            if (!classDeclaration.validate()) {
                deferredSymbols.add(classDeclaration)
                return@forEach
            }

            try {
                generateInputAndUpdateTypes(classDeclaration)
            } catch (e: Exception) {
                logger.error("Error generating types for ${classDeclaration.simpleName.asString()}: ${e.message}", classDeclaration)
                deferredSymbols.add(classDeclaration)
            }
        }

        return deferredSymbols
    }

    private fun generateInputAndUpdateTypes(classDeclaration: KSClassDeclaration) {
        val className = classDeclaration.simpleName.asString()
        val packageName = classDeclaration.packageName.asString()
        val typesPackageName = "$packageName.types"

        // Obter propriedades da classe
        val properties = classDeclaration.getAllProperties().toList()

        // Identificar propriedades com @Id
        val idProperties = properties.filter { property ->
            property.annotations.any { annotation ->
                annotation.shortName.asString() == "Id" ||
                        annotation.annotationType.resolve().declaration.qualifiedName?.asString() == Id::class.qualifiedName
            }
        }

        val idPropertyNames = idProperties.map { it.simpleName.asString() }.toSet()

        // Propriedades não-ID para Input e Update
        val nonIdProperties = properties.filter {
            it.simpleName.asString() !in idPropertyNames &&
                    it.isMutable // Apenas propriedades mutáveis
        }

        // Gerar classe Input (todas as propriedades não-ID são obrigatórias)
        generateDataClass(
            name = "${className}Input",
            packageName = typesPackageName,
            properties = nonIdProperties,
            makeNullable = false
        )

        // Gerar classe Update (todas as propriedades não-ID são opcionais)
        generateDataClass(
            name = "${className}Update",
            packageName = typesPackageName,
            properties = nonIdProperties,
            makeNullable = true
        )
    }

    private fun generateDataClass(
        name: String,
        packageName: String,
        properties: List<KSPropertyDeclaration>,
        makeNullable: Boolean
    ) {
        val classBuilder = TypeSpec.classBuilder(name)
            .addModifiers(KModifier.DATA)

        val constructorBuilder = FunSpec.constructorBuilder()

        properties.forEach { property ->
            val propertyName = property.simpleName.asString()
            val originalType = property.type.toTypeName()

            // Determinar o tipo final (nullable ou não)
            val finalType = if (makeNullable && !originalType.isNullable) {
                originalType.copy(nullable = true)
            } else {
                originalType
            }

            // Adicionar parâmetro ao construtor
            val parameterSpec = ParameterSpec.builder(propertyName, finalType).apply {
                if (makeNullable) {
                    defaultValue("null")
                }
            }.build()

            constructorBuilder.addParameter(parameterSpec)

            // Adicionar propriedade à classe
            val propertySpec = PropertySpec.builder(propertyName, finalType)
                .initializer(propertyName)
                .build()

            classBuilder.addProperty(propertySpec)
        }

        classBuilder.primaryConstructor(constructorBuilder.build())

        val fileSpec = FileSpec.builder(packageName, name)
            .addType(classBuilder.build())
            .addFileComment("AUTO-GENERATED by graphql-types-generator using KSP. Do not edit.")
            .build()

        // Escrever arquivo
        fileSpec.writeTo(codeGenerator, Dependencies(false))
    }
}
